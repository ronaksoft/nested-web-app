(function () {
  'use strict';

  angular
    .module('ronak.nested.web.components.sidebar')
    .controller('PlacesModalController', PlacesModalController);

  /** @ngInject */
  function PlacesModalController($q, $scope, $state, $stateParams, $uibModal, $rootScope, $timeout,
                                 _, toastr,
                                 NST_DEFAULT, NST_AUTH_EVENT, NST_INVITATION_EVENT, NST_CONFIG, NST_KEY, deviceDetector, NST_PLACE_ACCESS, NST_SRV_ERROR,
                                 NST_EVENT_ACTION, NST_USER_EVENT, NST_NOTIFICATION_EVENT, NST_SRV_EVENT, NST_NOTIFICATION_TYPE, NST_PLACE_EVENT, NST_POST_EVENT,
                                 NstSvcAuth, NstSvcServer, NstSvcLogger, NstSvcNotification, NstSvcTranslation, NST_PLACE_MEMBER_TYPE,
                                 NstSvcNotificationSync, NstSvcPlaceFactory, NstSvcInvitationFactory, NstUtility, NstSvcUserFactory, NstSvcSidebar,
                                 NstSvcKeyFactory, NstSvcPostDraft) {
    var vm = this;
    var eventReferences = [];
    var myPlaceOrders = {};
    var ABSENT_PLACE_PICTURE_URL = '/assets/icons/absents_place.svg';
    var myPlaceIds = [];
    vm.isLoading = true;
    vm.showLoading = showLoading;
    vm.toggleSelectPlace = toggleSelectPlace;
    vm.unselectAll = unselectAll;
    vm.selectedPlaces = [];
    vm.keyword = '';
    vm.openAddMemberModal = openAddMemberModal;
    vm.toggleNotification = toggleNotification;
    vm.toggleShowInFeed = toggleShowInFeed;
    vm.placesSetting = {
      relationView: true
    };

    vm.sortUpdateHandler  = sortUpdateHandler;
    function sortUpdateHandler() {
      setMyPlacesOrder(JSON.stringify(createSortedList(vm.places))).then(function () {
        toastr.success(NstSvcTranslation.get('Places sorting updated'));
      }).catch(function () {
        toastr.error(NstSvcTranslation.get('Something went wrong!'));
      });
    }

    function mapWithKey(items) {
      var list = {};
      for (var i in items) {
        for (var key in items[i]) {
          list[key] = items[i][key];
        }
      }
      return list;
    }

    function createSortedList(places) {
      var order = 0;
      return mapWithKey(_.map(places, function (item) {
        order++;
        return getSortedInfo(item, order);
      }));
    }

    function getSortedInfo(subPlace, order) {
      var subOrder = 0;
      var output = {};
      output[subPlace.id] = {};
      output[subPlace.id].o = order;
      if (subPlace.children && subPlace.children.length > 0) {
        output[subPlace.id].s = mapWithKey(_.map(subPlace.children, function (item) {
          subOrder++;
          return getSortedInfo(item, subOrder);
        }));
      }
      return output
    }

    showLoading();

    vm.sortableOptions = {
      // connectWith: ".place-ul",
      containment: "parent",
      // 'ui-floating': true,
      axis: 'y',
      handle: '> a > .dragger'
      // It is suggested to use the most specific cssselector you can,
      // after analyzing the DOM elements generated by the transclusion directive
      // eg: items: '> .transclusionLvl1 > .transclusionLvl2 > .sortable-item'
    };

    function showLoading() {
      vm.isLoading = true;
      $timeout(function () {
        vm.isLoading = false;
      }, 1000)
    }

    function toggleSelectPlace(place) {
      place.isSelected = !place.isSelected;
      var placeIndex = vm.selectedPlaces.indexOf(place);
      if (placeIndex > -1) {
        vm.selectedPlaces.splice(placeIndex, 1);
      } else {
        vm.selectedPlaces.push(place);
      }
    }

    function unselectAll() {
      vm.selectedPlaces.forEach(function (place) {
        place.isSelected = false;
      });
      vm.selectedPlaces = [];
    }

    /*****************************
     *** Controller Properties ***
     *****************************/
    vm.user = NstSvcAuth.user;
    vm.stateParams = $stateParams;
    vm.invitation = {};
    vm.places = [];
    vm.onPlaceClick = onPlaceClick;
    vm.openCreatePlaceModal = openCreatePlaceModal;
    vm.openCreateSubplaceModal = openCreateSubplaceModal;
    vm.expandedPlaces = [];
    vm.myPlacesUnreadPosts = {};
    vm.myPlacesHasUnseenChildren = [];
    vm.noAccessCreatingMessage = '';
    vm.selectedPlaceName = '';

    initialize();

    /*****************************
     ***** Controller Methods ****
     *****************************/

    function initialize() {
      vm.expandedPlaces = [];
      $q.all([getMyPlacesOrder(), getMyPlaces(true)]).then(function (results) {
        myPlaceOrders = results[0];
        vm.places = createTree(results[1], myPlaceOrders, vm.expandedPlaces, vm.selectedPlaceId);
      });

      loadCurrentUser();

    }

    /**
     * Represents the create place modal
     * @param {event} $event
     * @param {sting} style - common place or private place
     */
    function openCreateSubplaceModal($event, style) {
      if (style === 'open') {
        $state.go('app.place-create', {placeId: getPlaceId(), isOpenPlace: true}, {notify: false});
      } else {
        $state.go('app.place-create', {placeId: getPlaceId(), isClosePlace: true}, {notify: false});
      }
      $event.preventDefault();
    }

    /**
     * return the current place id
     * @returns string
     */
    function getPlaceId() {
      return vm.selectedPlaceId;
    }


    /**
     * Represents add member to place modal
     * @param {any} $event
     */
    function openAddMemberModal(placeId) {
      NstSvcPlaceFactory.get(placeId).then(function (place) {
        vm.placeModal = place;
        var role = NST_PLACE_MEMBER_TYPE.KEY_HOLDER;
        var modal = $uibModal.open({
          animation: false,
          templateUrl: 'app/pages/places/settings/place-add-member.html',
          controller: 'PlaceAddMemberController',
          controllerAs: 'addMemberCtrl',
          size: 'sm',
          resolve: {
            chosenRole: function () {
              return role;
            },
            currentPlace: function () {
              return vm.placeModal;
            },
            newPlace: false,
            mode: function () {
              return false
            },
            isForGrandPlace: function () {
              return undefined
            }
          }
        });

        modal.result.then();
      });

    }

    function loadCurrentUser() {
      vm.selectedPlaceId = null;
      NstSvcUserFactory.getCurrent(true).then(function (user) {
        vm.canCreateGrandPlace = user.limits.grand_places > 0;
        vm.user = user;
      });
    }

    function getMyPlaces(force) {
      return NstSvcPlaceFactory.getMyPlaces(force);
    }


    /**
     * Triggers on clicking place clicking
     * @param {any} event
     * @param {any} place
     */
    function onPlaceClick(event, place) {
      if (NstSvcSidebar.onItemClick) {
        event.preventDefault();
        NstSvcSidebar.onItemClick({
          id: place.id,
          name: place.name
        });
      } else {
        vm.selectedGrandPlace = place;
      }
    }

    /**
     * Represents the create place modal modal also shows a
     * warning modal if the user reached the create place limit
     */
    function openCreatePlaceModal() {
      $state.go('app.place-create', {}, {notify: false});
    }


    /*****************************
     *****    Place's Order   ****
     *****************************/

    /**
     * @function
     * Gets the grand places order from server
     * @returns {object}
     */
    function getMyPlacesOrder() {
      return NstSvcKeyFactory.get(NST_KEY.GENERAL_NEW_SETTING_PLACE_ORDER).then(function (result) {
        if (result) {
          return JSON.parse(result);
        }
        return {};
      });
    }

    function setMyPlacesOrder(data) {
      return NstSvcKeyFactory.set(NST_KEY.GENERAL_NEW_SETTING_PLACE_ORDER, data);
    }

    vm.range = function (num) {
      var seq = [];
      for (var i = 0; i < num; i++) {
        seq.push(i);
      }

      return seq;
    };

    /**
     * Returns true if the given Place is a child of the provided parent Place ID
     *
     * @param {any} parentId
     * @param {any} place
     * @returns
     */
    function isChild(parentId, place) {
      return place && place.id && place.id.indexOf(parentId + '.') === 0;
    }

    /**
     * Returns true if the item should be expanded in Places tree
     *
     * @param {any} place
     * @param {any} expandedPlaces A list of places that were expanded before.
     * @param {any} selectedId
     * @returns
     */
    function isItemExpanded(place, expandedPlaces, selectedId) {
      // In this case the the selected Place ID is exactly the same with current place ID or
      // the current Place ID is a subset of selected Place ID. Take a look at the examples:
      // |#  |Conditions         |Current             |Selected
      // |1  |both are the same  |company.marketing   |company.marketing
      // |2  |parent-child       |company             |company.marketing
      if (selectedId && _.startsWith(selectedId, place.id)) {
        return true;
      }
      // The place exists in expanded places list
      if (_.includes(expandedPlaces, place.id)) {
        return true;
      }

      return false;
    }

    /**
     * Filters the place children
     *
     * @param {any} place
     * @param {any} places
     * @param {any} expandedPlaces
     * @param {any} selectedId
     * @param {any} depth
     * @param {any} orders
     * @returns
     */
    function getChildren(place, places, expandedPlaces, selectedId, depth, orders) {
      var chain = _.chain(places).sortBy(['id']).reduce(function (stack, item) {
        // The child does not belong to the Place
        if (!isChild(place.id, item)) {
          return stack;
        }

        var previous = _.last(stack);
        // The place is a child of the previous item. Take a look at the following example:
        // Imagine a user Place tree is ordered in this way:
        // |A
        // |  A.X
        // |    A.X.K
        // |B
        // |  B.Y.J
        // Then a place's child goes right after its parent if we sort the list by ID
        if (previous && isChild(previous.id, item)) {
          return stack;
        }

        var isActive = (item.id === selectedId);
        var isExpanded = isItemExpanded(item, expandedPlaces, selectedId);
        var children = getChildren(item, places, expandedPlaces, selectedId, depth + 1, getOrder(orders, place.id));

        stack.push(createTreeItem(item, false, children, isExpanded, isActive, depth));

        return stack;
      }, []);

      if (orders !== null) {
        return chain.sortBy(function (place) {
          return orders[place.id]? orders[place.id].o: 1;
        }).value();
      } else {
        return chain.sortBy(['name']).value();
      }
    }

    function getOrder(order, id) {
      if (order && order[id] && order[id].s) {
        return order[id].s;
      } else {
        return null;
      }
    }

    /**
     * Toggles the notification property of place
     * @returns {boolean}
     */
    function toggleNotification(place) {
      place.notificationStatus = !place.notificationStatus;
      NstSvcPlaceFactory.setNotificationOption(place.id, place.notificationStatus).catch(function () {
        place.notificationStatus = !place.notificationStatus;
      });
    }

    /**
     * Toggles the notification property of place
     * @returns {boolean}
     */
    function toggleShowInFeed(place) {
      place.favorite = !place.favorite;
      NstSvcPlaceFactory.setBookmarkOption(place.id, place.favorite).catch(function () {
        place.favorite = !place.favorite;
      });
    }

    /**
     * Creates the user Places tree
     *
     * @param {any} places
     * @param {any} orders The order of grand Places. A user is allowed to reorder her grand Places
     * and we keep the order as a global setting between all user devices
     * @param {any} expandedPlaces
     * @param {any} selectedId
     * @returns
     */
    function createTree(places, orders, expandedPlaces, selectedId) {
      myPlaceIds = [];
      return _.chain(places).filter(function (place) {
        myPlaceIds.push(place.id);
        return place.id && place.id.indexOf('.') === -1;
      }).map(function (place) {
        var isActive = (place.id === selectedId);
        var isExpanded = isItemExpanded(place, expandedPlaces, selectedId);
        var children = getChildren(place, places, expandedPlaces, selectedId, 1, getOrder(orders, place.id));
        return createTreeItem(place, true, children, isExpanded, isActive, 0);
      }).sortBy(function (place) {
        return orders[place.id]? orders[place.id].o: 1;
      }).value();
    }

    /**
     * Creates an instance of tree item
     *
     * @param {any} place
     * @param {any} children
     * @param {any} isExpanded
     * @param {any} isActive
     * @param {any} depth
     * @returns
     */
    function createTreeItem(place, isGrandPlace, children, isExpanded, isActive, depth) {
      var picture = place.hasPicture() ? place.picture.getUrl('x32') : ABSENT_PLACE_PICTURE_URL;
      var placeModel = {
        id: place.id,
        name: place.name,
        picture: picture,
        privacy: place.privacy,
        accesses: place.accesses,
        isGrandPlace: isGrandPlace,
        isSelected: false,
        notificationStatus: place.notification,
        favorite: place.favorite, //TODO
        policy: place.policy,
        children: children,
        hasChildren: children && children.length > 0,
        hasUnseen: hasUnseen(place, vm.myPlacesUnreadPosts),
        childrenHasUnseen: anyChildrenHasUnseen(place, children, vm.myPlacesUnreadPosts),
        isExpanded: isExpanded,
        isActive: isActive,
        depth: depth
      };
      return placeModel;
    }

    /**
     * Iterates over the Place children and returns true if any child has unseen post
     *
     * @param {any} place
     * @param {any} children
     * @param {any} myPlacesUnreadPosts
     * @returns
     */
    function anyChildrenHasUnseen(place, children) {
      if (!place || _.size(children) === 0) {
        return false;
      }

      return _.some(children, function (child) {
        return child.hasUnseen;
      });
    }

    /**
     * Checks both the Place model and myPlacesUnreadPosts to find whether the Place has unseen posts or not
     *
     * @param {any} place
     * @param {any} myPlacesUnreadPosts
     * @returns
     */
    function hasUnseen(place, myPlacesUnreadPosts) {
      return place.unreadPosts > 0 || myPlacesUnreadPosts[place.id] > 0;
    }

  }
})();
